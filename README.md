# MAPFScenario

## File structure
- MapfScenario.jar - main executable. 
- config.properties - used to store program configuration
- action_durations - used in simulation. contains custom durations of the ozobot actions.
- template.ozocode - ozocode program file which is used by Ozocode generator as template to produce pathfinding program.
- workdir - program working direcory. contains files "pr<current_date>.pi" which are used by picatwrapper, and "out<current_date>.answ" which are result action of picatWrapper, and are used by simulator and ozocode generator.    
- picat/picat_iface.pi - picat interface is file which contains functions that picat exposes and can be used in MapfScenario
- lib/OzocodeGenerator.jar - runnable library which read files: out<date>.answ template.ozocode. and produces ozocode made of out<date>.answ file. 
- lib/PicatWrapper.jar - runnable libraray used to call platform dependent picat executable. Currently supports only linux and macOs.   



 
## Program can be divided into four logical components
- OzoCodeGenerator. Used to generate ozobot code. It is separate executable jar archive.
- PicatWrapper. Platform independent wrapper over picat libraries. Used to call picat methods from java. 
  picat folder - contains picat scripts, which are used to model and find solution for generated problem.  
- MapfScenario - gui program which is used interactively create multi agent path finding problem, call solver and vizualize result. Also calls components


## On button solver clicked workflow
1. currently drawn map is converted to graph, and with agents positions is written into file workdir/pr<current_date>.pi
2. picat interpreter (picatWrapper) is invoked with pr<current_date>.pi file path and file where out<date>.answ where picat output is expected
3. after picat interpreted had finished. out<date>.answ is read and parset.  



## Workdir file structures
workdir is folder used to store files whose are subject of passing to another component.

### pr<date>.pi
This file is generated when in MapfScenario button Solve is clicked. It contains all data about currently modeled problem written in picat term format.  

File consists of graph of nodes, and agent start and end positions
ins(IncidentGraph,AgentsPositions).

IncidentGraph = [neibs(VertexId,ListOfNeigbours), ... ]   
AgentPositions = [ (AgentVertexIdStart,AgentVertexIdEnd),... ]

IncidentGraph is list of terms neibs, where each term is representing graph vertexId and contains list of its neigbours.
AgentPositions is list of tuples where each tuple represnets one agent, and first value is start position of agent, second is agent goal position. 

file alco contains term idPosMap which is map, which can be used to map vertexIds back to grid location. 
```
Example file:
% Map num mapping
%(0,2) => 5
%(2,0) => 1
%(2,2) => 6
%(4,0) => 2
%(6,0) => 3
%(6,2) => 7
%(8,0) => 4
%(8,2) => 8

ins([
neibs(1,[2,6]),
neibs(2,[1,3]),
neibs(3,[2,4,7]),
neibs(4,[3,8]),
neibs(5,[6]),
neibs(6,[1,5]),
neibs(7,[3,8]),
neibs(8,[4,7])
],[(5,4),(8,5)]).
% Map from ID to coords (x, y) top left is (1,1) 
idPosMap([1 =(2,0),2 =(4,0),3 =(6,0),4 =(8,0),5 =(0,2),6 =(2,2),7 =(6,2),8 =(8,2)]).
```

```
Represents following map: format: nodeId(xCord,yCord)

         1(2,0)--2(4,0)--3(6,0)--4(8,0) 
           |               |       |
 5(0,2)--6(2,2)          7(6,2)--8(8,2)
```
Where there are two agents. One starts on node 5(bottom left), and wants to go to node 4 (top right) , and second is on node 8 and want to go to node 5.  


### out<date>.answ

This file is generated by picatWrapper after button Solver in MapfScenario is clicked.
To be more precise: MapfScenario generates file pr<data>.pi and gives it as argument to picatWrapper, which reads file and writes upon it solion file. This solution file is further used to visualize solution and to generate ozobot program. 

This file is readed line by line and contains picat generated plan for agents.
One line represents agent current position. Combination of two neigbour lines gives agent action. 

Example:
1 3 null east 2000 "east" 
1 4 null end 2000 "end"  

This says, that agent number 1, starts on vertex 3. performs operation east, which takes 2000 miliseconds. And after that operation agent is on vertex 4.

File contains six columns which are divided by space. 

Coumnus:
1. AgentNo - numbered from 1. Defines for which agent action holds.
2. VertexNo - vertexId as used in pr<date>.pi. Specifies Agent position beetween action.  
3. Rotation - can be ommited and set by null. Is clockwise value of agent current rotation in degrees. Zero is top, supports only nonnegative integer values
4. Action - it is label which says what action will be performed between current line and next. Last action of each agent should be always end.
5. Duration - if picat script supports action durations (miliseconds). It can specify how long each action will take. From view point of this file, action is transition beetween current line and the next one.
6. SomeText - for any debugging or another purposese. On simulation this text should be displayed when mouse hovered over its action  


## Picat
picat language and runtime is used to model Multiagent pathfinding algorithms. 
In folder picat is located file picat_iface.pi. When MapfScenario starts it reads this file line by line
and searches for lines starting with "%[SCENARIO_EXPORT]". For example:

%[SCENARIO_EXPORT] mapf_edge_split EdgeSplit

This line indicates that there is valid picat prediate mapf_edge_split that can be called from picat_iface.pi.
EdgeSplit is alias to given predicate which will be included in MapfScenario available solver list.
  
MapfScenario expects that given predicate will contain two arguments: Input_File, Output_File.
Input_File is path to existing file formated as pr<date>.pi.
Output_file is path to non existing file, to where given predicate should write algorithms result formatted as out<date>.answ.  

## PicatWrapper jar archive
Because picat interperter is platform dependent. It was compiled for linxu and macOs as a library.
And over it was written a simple wrapper, which calls picat interpreter with given picat file and predicate.
   
Aruments to call picatWraper manually:
workdir - folder where library is.
called Predicate - predicate with argumetns that will be run
picatModule - picat file with predicate to run. 

Example: ./picat mapf_edge_split("Full_Path.pi","Full_path.answ") picat_iface.pi



## Ozocode generator (jar archive)
Main purpose of this module is to convert picat solution file out<date>.answ to loadable ozobot program. 

ozobot program is a xml file.  To avoid future possible language changes. Writing program is done by xml inection into existing template.ozocode file. 

Suggested approach is following:
1. In ozoblockly create progam which contains needed functions named as actions definded as are given by picat or can be seen in simulation. Body of theses function is the code that ozobot has to perform for given action.
2. Create mock function named "ENTRYPOINT" (without quotes) and add a call of this function. No other executable code sould be present.
3. Export this program to file for example template.ozocode

When ozocode is generated from Mapf scenario
4. Specify path to template from tab settings-> ozobot template file.    
5. click ozo export on showed solution

When ozocode is genereted manually from OzocodeGenerator.jar

4. run command :
  java -jar OzocodeGenerator.jar <solution_input_file> <template_ozoblockly_xml> <output_ozobolockly_xml> agentNumber
   <solution_input_file> is file out<date>.answ
   <template_ozoblockly_xml> is prevously generated ozobot code
   <output_ozoblockly_xml>  is name of outpu file where template with injected code will be
   agentNumer is specified for what agent should be program generated. 

Note: Result ozocode program is a copy of generated template.ozocode, where call of function "ENTRYPOINT" is substituted with sequence of function calls which are actions given by solver algorthm.
  
    

